from urllib.parse import urlencode, urlparse, urlunparse

import requests

from solc.exceptions import ArgumentException, EmptyResponseException
from solc.models import Book, Author, Publisher


class SimpleOpenLibraryClient(object):
    base_url = 'https://openlibrary.org/'
    types = [
        'edition',
        'work',
        'author',
        'book',
    ]
    bibkeys = [
        'OCLC',
        'LCCN',
        'OLID',
        'ISBN',
    ]
    jscmd = [
        'data',
        'details',
        'viewapi',
    ]

    def __init__(self, cache=True, cache_name='solc_cache', cache_backend='sqlite', expire_after=None):
        if cache:
            import requests_cache
            requests_cache.install_cache(cache_name=cache_name, backend=cache_backend, expire_after=expire_after)

    @staticmethod
    def _request(url, method="GET", **kwargs):
        response = requests.request(method=method, url=url, **kwargs)
        if response.content is None or len(response.content) == 0 or len(response.json()) == 0:
            raise EmptyResponseException("'%s' response was empty" % url)
        return response.json()

    def request(self, url, **kwargs):
        """Request via self._request, kwargs are urlencoded

        :param url: URL...
        :rtype url: str
        :param kwargs: will be added to url
        :return: Object or list of objects
        """
        response = self._request(self._build_url(url, **{k: v for k, v in kwargs.items() if v is not None}))
        assert isinstance(response, dict)
        if len(response.values()) == 0:
            return False
        if 'docs' in response.keys() and isinstance(response['docs'], list):
            return [self._to_klass(entry) for entry in response['docs'] if isinstance(entry, dict)]
        if len(response.values()) > 1:
            return [self._to_klass(entry) for entry in response.values() if isinstance(entry, dict)]
        return self._to_klass(list(response.values())[0])

    def get(self, key):
        """Call on api/get with a key as identifier

        :param key:
        :rtype key: str
        :return:
        """
        value = self.request('api/get', key=key)
        if isinstance(value, list) and len(value) == 1:
            return value[0]
        return value

    def get_author_by_key(self, key: str):
        """Call on api/get with /a/ as prefix to the key

        :param key: OpenLibrary Author ID
        :type key: str
        :return: Author
        """
        return self.get(key="/a/%s" % key)

    def get_book_by_key(self, key: str):
        """Call on api/get with /b/ as prefix to the key

        :param key: OpenLibrary Author ID
        :type key: str
        :return: Author
        """
        return self.get(key="/b/%s" % key)

    def get_work_by_key(self, key: str):
        """Call on api/get with /works/ as prefix to the key

        :param key: OpenLibrary Author ID
        :type key: str
        :return: Author
        """
        return self.get(key="/works/%s" % key)

    def get_edition_by_key(self, key: str):
        """Call on api/get with /e/ as prefix to the key

        :param key: OpenLibrary Author ID
        :type key: str
        :return: Author
        """
        return self.get(key="/e/%s" % key)

    def _to_klass(self, entry: dict):
        """Converts entry/dict to class

        :param entry:
        :type entry: dict
        :return:
        :rtype: Book or Author
        """
        assert isinstance(entry, dict)

        type_ = False
        if 'type' in entry.keys():
            type_ = entry['type']
            if isinstance(type_, dict) and 'key' in type_.keys():
                type_ = type_['key']

        # todo: redo this...
        if "title" in entry.keys() or (isinstance(type_, str) and ('book' in type_ or 'work' in type_)):
            if "authors" in entry.keys():
                entry['authors'] = [Author(**x) for x in entry['authors']]
            if "publishers" in entry.keys():
                if isinstance(entry['publishers'], dict):
                    entry['publishers'] = [Publisher(**x) for x in entry['publishers']]
                elif isinstance(entry['publishers'], list):
                    entry['publishers'] = [Publisher(name=x) for x in entry['publishers']]
                else:
                    try:
                        entry['publishers'] = [Publisher(**entry['publishers'])]
                    except:
                        pass
            return Book(**entry)
        if isinstance(type_, str) and 'author' in type_:
            return Author(**entry)
        if "details" in entry.keys():
            return self._to_klass(entry['details'])
        return entry

    def _build_url(self, uri, **kwargs):
        """ build url

        :param uri: uri
        :param kwargs: args for in url
        :return: url
        :rtype: str
        """
        url_parts = list(urlparse(self.base_url))
        url_parts[2] = uri
        url_parts[4] = urlencode(kwargs, safe=':')
        return urlunparse(url_parts)

    def _format_type(self, type):
        """

        :param type: str
        :return: type
        :rtype: str
        """
        return '/type/%s' % type

    def search_book(self, q=None, title=None, author=None):
        """ Simple search
        :param q:
        :type q: str
        :param title:
        :type title: str
        :param author:
        :type author: str
        :return:
        """
        if q is None and title is None and author is None:
            raise ArgumentException("At least something must be provided to search for...")
        return self.request('/search.json', **{
            'q': q,
            'title': title,
            'author': author,
        })

    def get_book_by_bibkey(self, bibkey: str, value: str, jscmd: str = 'data'):
        """Get Book by a type of BIBKey

        :param bibkey: BIBKey format
        :type bibkey: str
        :param value:
        :type value: str
        :param jscmd:
        :type jscmd: str
        :return:
        :rtype: Book
        """
        if jscmd not in self.jscmd:
            raise ArgumentException("Invalid jscmd '%s', must be one of %s", (jscmd, ",".join(self.jscmd)))
        bibkey = bibkey.strip().upper()
        if bibkey not in self.bibkeys:
            raise ArgumentException(
                "Unknown type of bibkey: '%s', must be one of %s" % (bibkey, ', '.join(self.bibkeys)))
        return self.request('/api/books.json', bibkeys="%s:%s" % (bibkey, value), jscmd=jscmd)

    def get_book_by_isbn(self, value: str, jscmd: str = 'data'):
        """Get book by ISBN

        :param value: ISBN
        :type value: str
        :param jscmd: JSCMD
        :type jscmd: str
        :return: Book
        :rtype: Book
        """
        return self.get_book_by_bibkey("ISBN", value, jscmd=jscmd)

    def get_book_by_oclc(self, value: str, jscmd: str = 'data'):
        """Get book by OCLC

        :param value: OCLC
        :type value: str
        :param jscmd: JSCMD
        :type jscmd: str
        :return: Book
        :rtype: Book
        """
        return self.get_book_by_bibkey("OCLC", value, jscmd=jscmd)

    def get_book_by_lccn(self, value: str, jscmd: str = 'data'):
        """Get book by LCCN

        :param value: LCCN
        :type value: str
        :param jscmd: JSCMD
        :type jscmd: str
        :return: Book
        :rtype: Book
        """
        return self.get_book_by_bibkey("LCCN", value, jscmd=jscmd)

    def get_book_by_olid(self, value: str, jscmd: str = 'data'):
        """Get book by OLID

        :param value: OLID
        :type value: str
        :param jscmd: JSCMD
        :type jscmd: str
        :return: Book
        :rtype: Book
        """
        return self.get_book_by_bibkey("OLID", value, jscmd=jscmd)
